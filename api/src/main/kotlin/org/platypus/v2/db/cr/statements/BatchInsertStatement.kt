package org.platypus.v2.db.cr.statements

import org.platypus.v2.db.QueryBuilder
import org.platypus.v2.db.cr.StatementType
import org.platypus.v2.db.cr.Transaction
import org.platypus.v2.db.database.DbDialect
import org.platypus.v2.model.BaseModel
import org.platypus.v2.model.field.api.BaseField
import org.platypus.v2.model.field.magic.IdField
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.util.ArrayList
import java.util.LinkedHashMap

internal class BatchDataInconsistentException(message: String) : Exception(message)

open class BatchInsertStatement(
        dialect: DbDialect,
        val table: BaseModel<*>,
        val avoidAutoInc: Boolean = true
) : UpdateBuilder<List<Map<BaseField<*, *>, Any>>>(dialect, StatementType.INSERT, listOf(table)) {

    val data = ArrayList<MutableMap<BaseField<*, *>, Any?>>()
    var generatedKey: List<Map<BaseField<*, *>, Any>>? = null

    infix operator fun get(idPk: IdField<*>): Int = generatedKey as? Int ?: error("No key generated")

    open protected fun generatedKeyFun(rs: ResultSet?, inserted: Int): List<Map<BaseField<*, *>, Any>>? {
        val autoGeneratedKeys = arrayListOf<MutableMap<BaseField<*, *>, Any>>()

        val firstAutoIncColumn = autoIncColumns.firstOrNull()
        if (firstAutoIncColumn != null) {
            while (rs?.next() == true) {
                autoGeneratedKeys.add(hashMapOf(firstAutoIncColumn to rs.getObject(1)))
            }

            if (inserted > 1 && !dialect.supportsMultipleGeneratedKeys) {
                // H2/SQLite only returns one last generated key...
                (autoGeneratedKeys[0][firstAutoIncColumn] as? Number)?.toLong()?.let {
                    var id = it

                    while (autoGeneratedKeys.size < inserted) {
                        id -= 1
                        autoGeneratedKeys.add(0, hashMapOf(firstAutoIncColumn to id))
                    }
                }
            }

            /** FIXME: https://github.com/JetBrains/Exposed/issues/129
             *  doesn't work with MySQL `INSERT ... ON DUPLICATE UPDATE`
             */
//            assert(isIgnore || autoGeneratedKeys.isEmpty() || autoGeneratedKeys.size == inserted) {
//                "Number of autoincs (${autoGeneratedKeys.size}) doesn't match number of batch entries ($inserted)"
//            }
        }

        arguments().forEachIndexed { itemIndx, pairs ->
            pairs.forEach { (col, value) ->
                if (!col.isAutoInc) {
                    val map = autoGeneratedKeys.getOrElse(itemIndx) {
                        hashMapOf<BaseField<*, *>, Any>().apply {
                            autoGeneratedKeys.add(itemIndx, this)
                        }
                    }
                }
            }
        }
        return autoGeneratedKeys
    }

    fun addbatch(){
        if (data.isNotEmpty()) {
            validateLastBatch()
            data[data.size - 1] = LinkedHashMap(values)
            values.clear()
        }
        data.add(values)
    }

    internal open fun validateLastBatch() {
        val cantBeDefaulted = (data.last().keys - values.keys).filterNot { it.isDefaultable() }
        if (cantBeDefaulted.isNotEmpty()) {
            val columnList = cantBeDefaulted.joinToString { it.completeName }
            throw BatchDataInconsistentException("Can't add new batch because fields: $columnList don't have client default values. DB defaults don't support in batch inserts")
        }
        val requiredInTargets = (targets.flatMap { it.fields } - values.keys).filter { !it.isDefaultable() && !it.type.isAutoInc }
        if (requiredInTargets.any()) {
            throw BatchDataInconsistentException("Can't add new batch because fields: ${requiredInTargets.joinToString()} don't have client default values. DB defaults don't support in batch inserts")
        }
    }

    override fun prepareSQL(): String {
        val builder = QueryBuilder(true)
        val values = if (avoidAutoInc) {
            arguments().first().filter { !it.first.isAutoInc }
        } else {
            arguments().first()
        }
        val sql = if (values.isEmpty()) {
            ""
        } else values.joinToString(prefix = "VALUES (", postfix = ")") { (col, value) ->
            builder.registerArgument(dialect, col, value)
        }
        val columns = values.map { it.first }
        val (columnsExpr, valuesExpr) = if (columns.isNotEmpty()) {
            columns.joinToString(prefix = "(", postfix = ")") { dialect.identity(it) } to sql
        } else "" to dialect.DEFAULT_VALUE_EXPRESSION

        return "INSERT INTO ${dialect.identity(table)} $columnsExpr $valuesExpr"
    }

    override fun PreparedStatement.executeInternal(): Int {
        val inserted = if (arguments().count() > 1 || isAlwaysBatch) executeBatch().sum() else executeUpdate()
        return inserted.apply {
            val rs = if (autoIncColumns.isNotEmpty()) {
                generatedKeys
            } else null
            generatedKey = generatedKeyFun(rs, this)
        }
    }

    protected val autoIncColumns = targets.flatMap { it.fields }.filter { it.isAutoInc && it.store }

    override fun prepared(cr: Transaction, sql: String): PreparedStatement {
        return if (autoIncColumns.isNotEmpty()) {
            // http://viralpatel.net/blogs/oracle-java-jdbc-get-primary-key-insert-sql/
            cr.prepareStatement(sql, autoIncColumns.map { dialect.identity(it) }.toTypedArray())!!
        } else {
            cr.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS)!!
        }
    }

    override fun arguments() = listOf(values.map { it.key to it.value })
}
