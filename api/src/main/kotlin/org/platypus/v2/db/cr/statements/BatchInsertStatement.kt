package org.platypus.v2.db.cr.statements

import org.platypus.v2.db.database.DbDialect
import org.platypus.v2.model.BaseModel
import org.platypus.v2.model.field.api.BaseField
import org.platypus.v2.model.field.api.DefaultValueMarker
import java.sql.ResultSet
import java.util.*

internal class BatchDataInconsistentException(message: String) : Exception(message)

open class BatchInsertStatement(
        dialect: DbDialect,
        table: BaseModel<*>,
        ignore: Boolean = true
) : InsertStatement<List<Map<BaseField<*, *>, Any>>>(dialect, table, ignore) {

    override val flushCache: Boolean = false

    override val isAlwaysBatch = true

    val data = ArrayList<MutableMap<BaseField<*, *>, Any?>>()

    override operator fun <S : Any> set(column: BaseField<*, S>, value: S) {
        if (data.size > 1 && column !in data[data.size - 2]) {
            throw BatchDataInconsistentException("Can't fieldSet $value for ${column.fieldName} because this field don't exist in previous insertion.")
        }
        super.set(column, value)
    }

    fun addBatch() {
        validateLastBatch()
        data.add(LinkedHashMap(values))
        values.clear()
    }

    override fun forceSet(column: BaseField<*, *>, value: Any?) {
        if (!column.required && value == null) {
            error("Trying to forceSet null to not required column $column")
        }
        if (value != null) {
            values[column] = value
        }
    }

    internal open fun validateLastBatch() {
        val requiredInTargets = (targets.flatMap { it.fields } - values.keys).filter { it.required && !it.isAutoInc }
        if (requiredInTargets.any()) {
            throw BatchDataInconsistentException("Can't add new batch because fields: ${requiredInTargets.joinToString()} don't have default values. DB defaults don't support in batch inserts")
        }
    }

    override fun arguments() = data.map { it.map { it.key to it.value }.filter { it.second != DefaultValueMarker } }

    override fun generatedKeyFun(rs: ResultSet?, inserted: Int): List<Map<BaseField<*, *>, Any>>? {
        val autoGeneratedKeys = arrayListOf<MutableMap<BaseField<*, *>, Any>>()

        val firstAutoIncColumn = autoIncColumns.firstOrNull()
        if (firstAutoIncColumn != null) {
            while (rs?.next() == true) {
                autoGeneratedKeys.add(hashMapOf(firstAutoIncColumn to rs.getObject(1)))
            }

            if (inserted > 1 && !dialect.supportsMultipleGeneratedKeys) {
                // H2/SQLite only returns one last generated key...
                (autoGeneratedKeys[0][firstAutoIncColumn] as? Number)?.toLong()?.let {
                    var id = it

                    while (autoGeneratedKeys.size < inserted) {
                        id -= 1
                        autoGeneratedKeys.add(0, hashMapOf(firstAutoIncColumn to id))
                    }
                }
            }

            /** FIXME: https://github.com/JetBrains/Exposed/issues/129
             *  doesn't work with MySQL `INSERT ... ON DUPLICATE UPDATE`
             */
//            assert(isIgnore || autoGeneratedKeys.isEmpty() || autoGeneratedKeys.size == inserted) {
//                "Number of autoincs (${autoGeneratedKeys.size}) doesn't match number of batch entries ($inserted)"
//            }
        }

        arguments().forEachIndexed { itemIndx, pairs ->
            pairs.forEach { (col, value) ->
                if (!col.isAutoInc) {
                    val map = autoGeneratedKeys.getOrElse(itemIndx) {
                        hashMapOf<BaseField<*, *>, Any>().apply {
                            autoGeneratedKeys.add(itemIndx, this)
                        }
                    }
                    if (value != null && data[itemIndx][col] == null) {
                        map[col] = value
                    }
                }
            }
        }
        return autoGeneratedKeys
    }
}
